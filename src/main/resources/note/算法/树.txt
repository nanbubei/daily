

节点的高度=节点到叶子节点的最长路径
节点的深度=根节点到这个节点所经历的边的个数
节点的层数=节点的深度+1
树的高度=根节点的高度
(我们把没有子节点的节点叫作叶子节点或者叶节点)

二叉树:
    满二叉树:
    叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树
    完全二叉树:
    叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。
二叉树的遍历:
    前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
    中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
    后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

二叉查找树
    二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

	1. 二叉查找树的查找操作
		我们先取根节点，如果它等于我们要查找的数据，那就返回。
		如果要查找的数据比根节点的值小，那就在左子树中递归查找；
		如果要查找的数据比根节点的值大，那就在右子树中递归查找。
	2. 二叉查找树的插入操作
		新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。
		如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；
		如果不为空，就再递归遍历右子树，查找插入位置。
		同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；
		如果不为空，就再递归遍历左子树，查找插入位置。
	3. 二叉查找树的删除操作
		针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。
		a.如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。
			比如图tree-1.jpg中的删除节点 55。
		b.如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。
			比如图tree-1.jpg中的删除节点 13。
		c.如果要删除的节点有两个子节点，这就比较复杂了。
		我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。
		然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），
		所以，我们可以应用上面两条规则来删除这个最小节点。
			比如图tree-1.jpg中的删除节点 18。
		(实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。
			这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。
			而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。)

	二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。


红黑树:
	根节点是黑色的；
	每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
	任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
	每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；


