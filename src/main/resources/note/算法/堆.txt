堆Heap
一种特殊的树,满足两点:
	完全二叉树;
	堆中每一个节点的值都大于等于(或小于等于)其子树中每个节点的值
		*对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”。
		 对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆”。
1. 往堆中插入一个元素
往堆中插入一个元素后，我们需要继续满足堆的两个特性。
如果我们把新插入的元素放到堆的最后，有时候是不符合堆的特性了。
于是，我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫作堆化（heapify）。

堆化实际上有两种，从下往上和从上往下:
堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。
我们可以让新插入的节点与父节点对比大小。
如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。
一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。

2. 删除堆顶元素
把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。
对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，
直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。

基于堆实现排序

我们可以把堆排序的过程大致分解成两个大的步骤，建堆和排序。
1. 建堆
第一种是借助我们前面讲的，在堆中插入一个元素的思路。
尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。
然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。
这样我们就将包含 n 个数据的数组，组织成了堆。

第二种实现思路，跟第一种截然相反。
第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。
而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。


2. 排序