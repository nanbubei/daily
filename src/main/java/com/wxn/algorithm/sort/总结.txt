冒泡:
	比对相邻的两个数据,并移动
	每次冒泡 都会把最大的数字放到最后(升序)
	外层循环i,要循环array.length次
	内层循环j,要循环array.length-i-1次(因为最后的i+1位已经是排序后的了)
	4	5	6	3	2	1
	4	5	3	2	1	6
	4	3	2	1	5	6
	3	2	1	4	5	6
	2	1	3	4	5	6
	1	2	3	4	5	6

	优化: 外层循环内维护一个变量, 如果一轮内层循环后没有进行过移动, 证明已经是有序的,即可以结束循环。

插入:
	一个有序的数组,把一个新数据插入相应的位置,数组还能保持有序。
	而把一个未排序数组的第0个元素看成已排序区间，后面的1-n个元素看作未排序区间，依次遍历插入插入，就是插入排序。
选择:
	分成已排序区间和未排序区间, 每次将未排序区间的最小值放到已排序区间的末尾


